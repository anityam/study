{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"root","n":1},"1":{"v":"\nThis is the root for your Dendron vault.\n\nIf you decide to publish your entire vault, it will be your landing page. You are free to customize any part of this page except the frontmatter at the top, between the `---`.\n","n":0.158}}},{"i":2,"$":{"0":{"v":"Tutorial","n":1},"1":{"v":"\nWelcome to Dendron! Dendron is a developer-focused knowledge base that helps you manage information using **flexible hierarchies**!\n\nYou are currently in the tutorial vault (a vault is the folder where your notes are stored). Feel free to edit this note and create new files as you go through the quickstart!\n\n## Create a Note\n\n1. Use `Ctrl+L` / `Cmd+L` to bring up the lookup prompt\n1. Type `dendron` and select `Create New`\n\n- > NOTE: After you press enter, Dendron will create and open the `dendron` note. Use `<CTRL>-<TAB>` to come back to this note\n\nYou just created your first note!\n\n- > NOTE: Notes in Dendron are just plain text markdown with some [frontmatter](https://wiki.dendron.so/notes/ffec2853-c0e0-4165-a368-339db12c8e4b) on the top. You can edit them in Dendron or using ~~vim~~ your favourite text editor.\n\n## Find a Note\n\n1. Use `Ctrl+L` / `Cmd+L` to bring up the lookup prompt again\n1. Type `dendron` and press `<ENTER>`\n\n- > TIP: you don't have to type out the entire query, press `<TAB>` to autocomplete\n\nYou just `looked up` a note!\n\n- > NOTE: in Dendron, you can find or create notes using the lookup prompt\n\n## Organize your Notes\n\n1. Bring up the lookup prompt again\n1. Type `tutorial.one`\n\nYou just created your first hierarchy!\n\n- > NOTE: hierarchies in Dendron are just `.` delimited files. This makes each note both a file and a folder and makes it easy to keep your notes organized\n\n- > TIP: You can use the [Dendron Tree View](https://wiki.dendron.so/notes/hur7r6gr3kqa56s2vme986j) to view your hierarchy. If it's not currently in focus, you can use `CTRL+SHIFT+P`/`CMD+SHIFT+P` to open the command prompt and type in `Dendron: focus on tree view` to make it appear\n\n## Create a link\n\n1. In the current note, type `[[` - this should trigger the autocomplete. You can type `one` to narrow it down to the note you just created and hit enter\n<!-- Enter '[[' below-->\n\n<!-- End space-->\n\nYou just created your first link!\n\n- > NOTE: the links with the `[[` are called wikilinks (because they were first popularized by Wikipedia)\n- > TIP: If you hover your mouse over the link, you can get a preview of the contents inside the note!\n\n## Navigate a link\n\n1. Move your text cursor over the link you just created. Hold down `<CTRL>+<ENTER>`/`<CMD>+<ENTER>`\n\n- > TIP: You can also use `CTRL+CLICK` or `CMD+CLICK` to navigate links via mouse\n\nYou just navigated the link!\n\n## Refactor a Note\n\n1. Open [[tutorial.one]], bring up the command prompt (`CTRL+SHIFT+P`/`CMD+SHIFT+P`) and type `Dendron: Rename Note`\n1. Replace `tutorial` with `my-note` and then press `<ENTER>`\n1. You just refactored the note!\n\n- > NOTE: when you rename a note, Dendron updates all links and references of the original note being renamed. Try switching back to [[tutorial]] to see the updated link!\n- > TIP: in addition to renaming one note at a time, dendron has [an entire collection](https://wiki.dendron.so/notes/srajljj10V2dl19nCSFiC) of refactoring commands that let you change headers, move around sections, and refactor entire hierarchies!\n\n## Conclusion\n\nCongrats, you finished the Dendron tutorial!\n\nWas there anything **unclear or buggy** about this tutorial? Please [**report it**](https://github.com/dendronhq/dendron/discussions/3266) so we can **make it better**!\n\n## Next Steps\n\nDepending on your needs, here are some common next steps:\n\n- I want to **start writing**: [Create a daily journal note](command:dendron.createDailyJournalNote) ([docs](https://wiki.dendron.so/notes/ogIUqY5VDCJP28G3cAJhd))\n\n- I want to **use templates**: Use the [Appy Template](https://wiki.dendron.so/notes/ftohqknticu6bw4cfmzskq6) command to apply [templates](https://wiki.dendron.so/notes/861cbdf8-102e-4633-9933-1f3d74df53d2) to existing notes\n\n- I want to do a **longer tutorial**: Check out our [5min tutorial to explore more of Dendron's functionality](https://wiki.dendron.so/notes/678c77d9-ef2c-4537-97b5-64556d6337f1/)\n\n- I want to **implement a particular workflow** (bullet journal, zettelkasten, etc): Check out community [workflow guides](https://wiki.dendron.so/notes/9313b845-d9bf-42c9-aad1-0da34794ce26)\n\n- I want to use Dendron for **tasks and todos**: See the [Getting Things Done (GTD), Bullet Journaling, and Other Task Management Workflows](https://wiki.dendron.so/notes/ordz7r99w1v099v14hrwgnp) for how the founder of Dendron uses it to manage his work.\n\n- I want to explore **advanced features**: See [next steps](https://wiki.dendron.so/notes/TflY5kn29HOLpp1pWT9tP) for longer walkthroughs and advanced functionality!\n\n- I want to start clean with a **new vault at a custom location**: Run [Dendron: Initialize Workspace](command:dendron.initWS) from the command prompt (or click this link) to start from a clean slate\n\n- I want to use Dendron as a **knowledge base for my team**: Read the [Dendron team setup](https://wiki.dendron.so/notes/98f6d928-3f61-49fb-9c9e-70c27d25f838) to get started\n\n> Coming from Obsidian? Click [here](command:dendron.importObsidianPod) to import your Obsidian notes (or any markdown notes) into Dendron to see how they look.\n\n## Community\n\nDendron is more that just a tool - we are also a community of individuals that are passionate about knowledge management. If you need help or want to connect with the community, join us in the [Discords](https://link.dendron.so/discord).\n\nYou can also:\n\n- Star us on [GitHub](https://github.com/dendronhq/dendron)\n- Follow us on [Twitter](https://twitter.com/dendronhq)\n- Subscribe to the [Dendron Newsletter](https://link.dendron.so/newsletter)\n","n":0.037}}},{"i":3,"$":{"0":{"v":"Programming","n":1}}},{"i":4,"$":{"0":{"v":"Go","n":1}}},{"i":5,"$":{"0":{"v":"Container","n":1},"1":{"v":"# Container\nShip fast, Ship light and once environment every where.\n\n","n":0.316}}},{"i":6,"$":{"0":{"v":"tools","n":1},"1":{"v":"# Tools\n\nTools are the basic building blocks of doing any work. So knowing the tools for work is the uptmost important details.\n\n\n","n":0.213}}},{"i":7,"$":{"0":{"v":"Validation","n":1},"1":{"v":"# Validation\n\n## Validating Istio tools\n","n":0.447}}},{"i":8,"$":{"0":{"v":"kubernetes","n":1},"1":{"v":"# Kubernetes \nThe major orchestration tool in the market that every one uses. \n\n","n":0.267}}},{"i":9,"$":{"0":{"v":"tools","n":1},"1":{"v":"# Kubernetes Tools\nThis section is a subset of Containers tools where we will entirely discuss upon kubernetes based tools.\n\n## Management\nThe tools that can be used to manage the kubernetes cluster itself.\n\n### K9\nTool to manage kubernetes.[[Container.kubernetes.tools.K9]]\n\n\n## Shell\n### Kubectx\n`brew install kubectx` This will make it easy to change context between different kubernetes cluster defined in your config file. More detail on [installation](https://github.com/ahmetb/kubectx)\nSetting up autocompletion for kubens and kubectx \n```bash\n mkdir ~/.oh-my-zsh/custom/completions\n chmod -R 755 ~/.oh-my-zsh/custom/completions\n```\nGet the zsh autocompletion from the github repo and create a file in the `~/.oh-my-zsh/custom/completions/{_kubectx.zsh,_kubens.zsh}`. Make it executable and check the script for the location of the cli in your environment. then\n```bash\necho \"fpath=($ZSH/custom/completions $fpath)\" >> ~/.zshrc\n```\n If it still doesn't workout after the source of `~/.zshrc` then add `autoload -U compinit && compinit` to your `zshrc`\n\n### Kubens \n`brew isntall kubectx` will install the kubens tools too which is useful in changing the namespace quickly.\n\n### Kube-ps1\nThis is a addons prompt for the zsh or bash\n```brew install kube-ps1```\n\nupdate your `.zshrc` to add \n```\nplugins=(\n  kube-ps1\n)\n\nPROMPT='$(kube_ps1)'$PROMPT # or RPROMPT='$(kube_ps1)'\n```\n\n### Stern\nFor logs \n```\nbrew install stern\n```\n\n### Popeye\nFind vulnerability in k8 cluster\n```\nbrew install derailed/popeye/popeye\n```\n\n### zsh plugins\nKubectl plugin add it to the `~/.zshrc`\n```\nplugins=(\n    ...\n    kubectl\n)```\n\n\n\n\n\n## Document\nhttps://agrimprasad.com/post/supercharge-kubernetes-setup/ ---> Kubernetes setup\nhttps://github.com/ahmetb/kubectx Kubectx Project\nhttps://github.com/stern/stern --> stern project\nhttps://agrimprasad.com/post/supercharge-kubernetes-setup/ \n","n":0.071}}},{"i":10,"$":{"0":{"v":"Kustomize","n":1},"1":{"v":"# Kustomize\nThis is an important tool that works with kubectl and is widely used in the kubernetes world. This is somehow a substitution of Helm or template based structuring of kubernetes resources.\n\n\n## Documentation\nThe documentation for [kustomize is located here](https://kubectl.docs.kubernetes.io/guides/)","n":0.16}}},{"i":11,"$":{"0":{"v":"K9","n":1},"1":{"v":"# K9\nThis is a tool that can be used to manage the kubernetes cluster. The location for more info on the tool itself is located at [github/k9](https://github.com/derailed/k9s).\n\n## Installation\n```brew install derailed/k9s/k9s```\n\n## Experience\nThe tool is really useful to view a lot of items at once in your cluster. It creates a new terminal based app where you will be able to view all the container based on namespace. Kill or log into pods based on your access level in the cluster and also will be able to get logs. This is helpful when doing an overall inspection of the cluster level and looking at logs. This can be used to tail logs and save the logs locally too.","n":0.093}}},{"i":12,"$":{"0":{"v":"Service mesh","n":0.707},"1":{"v":"# Service Mesh\nThe way to manage traffic inside the kubernetes cluster. The services in a fast pace microservice type environment where many applications are talking to each other, the requirements for the proxy( connection flows) for each application becomes to huge to manually manage. \nInstead of injecting logic on each service or having many services for an application is cumbersome. Therefore a service mesh is an infrastructure that handles the data plane for all the services and controls the flow of traffic in a cluster. With  a service mesh the logic for traffic flow \ncan be a stand alone application without introducing the network logic in the application design. Istio is a open source service mesh popular in the company standard. \n\n## Istio\n## Installation \nThe installation of istio control plane is done at the `istio-system` namespace. The process for installation can be followed at https://github.com/anityam/istio . The installation will install the control plane at `istio-system`.\n\n## Component\nIstiod --> This is the main component of the control plane. The custom resources that istio uses like `virtualhost` are converted to envoy configs by istiod\n\n## Traffic Entry point\nThe traffic in the istio cluster moves inside the cluster through the **INGRESS** resource.\n### Concept\nIstiod is the controller for the Ingress resource. It looks at the configs and configures the envoy based proxy. This can have a corresponding nodePort or external cloud based loadbalancer that exposes the traffic \n\n#### Envoy Proxy\n\n\n## Concept\nIstio keeps a database of it's managed service and service endpoints in a registry called service registry. The envoy proxy uses this service registry to route the traffic. Istio has a mechanism of service discovery (Pilot) or [ServiceEntry](https://istio.io/latest/docs/reference/config/networking/service-entry/) configuration can be added to add the service to the service Registry.\nEnvoy proxy distributes traffic based on least load model. If there are more than two loadbalancer or host receiving the traffic than envoy routes the traffic to the host that is handling the least amount of traffic\nOutside of the routes istio can also split traffic across instances \n\n## Apis\n1. Virtual Service\n2. Destination Rule\n3. Service Entry\n4. Gateways\n5. Sidecars\n\n### Ingress Gateway\nThe entry point to the cluster. This is deployed in the `istio-system` namespace. This uses an Envoy proxy for the traffic coming from outside the cluster which is usually a loadbalancer(for external cloud based deployment) or a nodeport. We can use `istioctl` to inspect all the traffic flows that are being listed in the ingress gateway envoy filter. The process running inside the ingressgateway is the \n```bash\nk exec -n istio-system deploy/istio-ingressgateway -- ps  \n    PID TTY          TIME CMD\n      1 ?        00:00:04 pilot-agent\n     20 ?        00:00:21 envoy\n     39 ?        00:00:00 ps\n```\nThe `pilot-agent` bootstraps the envoy filter and creates the rules which can be view by\n```bash\nistioctl -n istio-system proxy-config route deploy/istio-ingressgateway\nNAME     VHOST NAME     DOMAINS     MATCH                  VIRTUAL SERVICE\n         backend        *           /stats/prometheus*     \n         backend        *           /healthz/ready*        \n```\n\nThe next chapter is to open up the traffic flow inside the cluster\n\n### Gateway\nGateway are how traffic comes to the cluster and then it can be routed to a virtual service. The gateway opens up a specific port on the ingress-gateway for incoming traffic. once a gateway is deploy \n```bash\nk get gateway\nNAME                AGE\ncoolstore-gateway   63s\n```\n\nNow when we look at the envoy proxy-config we will see the port being opened \n```bash\nistioctl -n istio-system proxy-config route deploy/istio-ingressgateway\nNAME          VHOST NAME         DOMAINS     MATCH                  VIRTUAL SERVICE\nhttp.8080     blackhole:8080     *           /*                     404\n              backend            *           /stats/prometheus*     \n              backend            *           /healthz/ready* \n```\n**blackhole** is due to the absence of any routing to the upstream cluster. Therefore all the traffic is now passed to a blackhole of 404 so when you hit the endpoint `http://127.0.0.1:3000/` (port 3000 is due to the nodePort setup of istio-ingressgateway) we will see a 404\n\n\n### Virtual Service\nThis routes the traffic from to specific services at the backend. It can be used to define routes to various real services based on the rules.In the VirtualService we will define the routes specified for the upstream traffic. Once the virtual service defines the traffic we can see the traffic routes in the proxy\n\n```bash\nistioctl -n istio-system proxy-config route deploy/istio-ingressgateway\nNAME          VHOST NAME                       DOMAINS                     MATCH                  VIRTUAL SERVICE\nhttp.8080     webapp.istioinaction.io:8080     webapp.istioinaction.io     /*                     webapp-vs-from-gw.istioinaction\n              backend                          *                           /stats/prometheus*     \n              backend                          *                           /healthz/ready* \n```\nWith the route set now the webpage can be viewed at `http://webapp.istioinaction.io:3000/` (here the http://weapp.istioinaction.io is pointing to 127.0.0.1 at `/etc/hosts`). \n### Destination Rule \nThis handles traffic to the specific destination. This is behind the virtual service once the traffic is directed to specific host then the destination service can apply the rules to the traffic\n\n\n### Service Entry\nThis is usually used to define a traffic leaving a cluster where a specific call in the cluster can be routed to an entry point pointing to the external cluster.\n\n### sidecars\nTo define a special rules for the sidecars used by the istio\n\n\n\n\n\n\n\n## Document\nhttps://istio.io/latest/docs/concepts/traffic-management/ --> Traffic management read\nhttps://banzaicloud.com/blog/backyards-ingress/  ---> Ingress Istio\nhttps://istio.io/latest/docs/concepts/traffic-management/#virtual-services --> Virtual Service","n":0.036}}},{"i":13,"$":{"0":{"v":"Envoy","n":1},"1":{"v":"# Envoy\n\nEnvoy is the backbone of the Istio service mesh. It is an open source project that lives in https://envoyproxy.io .\n\nIt is a transparent proxy. The main concept of which was established to create a transparent network proxy which is easy to debug. A proxy is a middleman that sits between the client and the server and through which the traffic flows for the communication between server and client.\n Client ---> Proxy ---> Server\n Technically a proxy can stand between the client and server and simplify the setting. The communication logic can be placed in the proxy without the server and client having to delete with the communication logic and able to focus on their specific client or server based logics.\n\n## Concept\n Envoy is designed as an application level proxy and can understand the layer 7 protocols. It can be extended to understand other level proxies. Lot of more telemetries come out of box due to Envoy understanding application level protocols\n\n\n## Feature\nListeners --> ports where downstream(something sending information from to the server or to the )\nRoutes --> The route setup for the downstream routes to be moved to the upstream clusters\nClusters --> the server portion or the \n\n### Service Discovery\nIt uses service discovery api to look for the service. \n\n### Load Balancing\nIt uses local-aware load balancing. Can be configured to use other routing strategies.\n\n### Traffic and Request Routing\nSophisticated routing rules since it can understand L7 protocols like HTTP/1 or HTTp/2\n\n### Traffic Shifting and Shadowing\nEnvoy can split traffic based on weight and also move copy of traffic to certain version( only a copy of the traffic the real flow still can use the other version)\n\n### Network Resilience\nRetries, timeouts, Health checks can be configured in Envoy.\n\n### Metrics\nIt can generate a lot of metrics\n\n### Tracing\nIt will generate x-request-id header to trace traffic.\n\n### Tls and Mutul Tls, Tls termination \n\n### Rate limiting\n\n\n## Documents \n\nhttps://envoyproxy.io ---> the main place for envoy\nhttps://www.envoyproxy.io/docs/envoy/v1.27.0/intro/arch_overview/intro/terminology --> docs","n":0.056}}},{"i":14,"$":{"0":{"v":"Kind","n":1},"1":{"v":"# Kind \n\nThis is a local development environment. This is a tool to build a local k8 cluster in your local laptop for testing or development.The tool is maintained by the kubernetes team.\n\n## Usage \nIt is based on the concept of creating a kubernetes cluster with containers. So it does required the presence of docker or any other container runtime in the system be present. `kind` is a local cli tool that can be use to create, delete or interact with the cluster.\n\n\n### Cli\nThe cli can be installed through go\n```bash \ngo install sigs.k8s.io/kind\n```\n\nIn mac it can be installed through brew\n```bash\nbrew install kind\n```\n\n\n\n## Document\nhttps://kind.sigs.k8s.io/ ---> Kind Docs","n":0.097}}},{"i":15,"$":{"0":{"v":"cluster","n":1},"1":{"v":"\n# Cluster \nThe main orchestration tool for the contianers that will be deployed. The approach is to have a local cluster using a tool like kind or minikube and then deploye and maintain the resources in the cluster using a tool like flux.\n\n## Local Deployment\nThe main initial step for the cluster is to have an infrastrucutre where the cluster can be installed. Just like any other piece of software the cluster orchestration tool requires an infrastructure which is a seriers of servers or contianers that provides an interface like a server.In a enterprise level that can be a datacenter with a series of servers with extensive cpus, memory and storage or a cloud based interface like eks, ecs etc. For a local deployment we will be using the virtualization tools like hyperV to build a virutal servers or container based environment with kind or minikube.\n\nIn this example we will use KinD.\n\n","n":0.081}}},{"i":16,"$":{"0":{"v":"tools","n":1},"1":{"v":"\n# Tools\n\n## KinD\nBasically stands for Kubernetes in Docker. As the name suggests this is a tool to instantiate a kubernetes cluster using docker containers in a local system. The location for this project is at [github/KinD](https://github.com/kubernetes-sigs/kind).\n\n### Installation\nKinD can be installed using the go programming language ```go install sigs.k8s.io/kind@v0.20.0``` or with brew  ```brew install kind```\n","n":0.136}}}]}
